name: Sync BMAD Tasks to ClickUp (Epics & Stories)

on:
  workflow_dispatch:
    inputs:
      sync_all:
        description: 'Sync all epic and story files (ignore git diff)'
        required: false
        type: boolean
        default: false  # Enable manual trigger
  push:
    branches: [main]
    paths:
      - '_bmad-output/planning-artifacts/epics/**/*.md'
      - '_bmad-output/planning-artifacts/stories/**/*.md'

env:
  CLICKUP_EPICS_LIST_ID: "901815396322"
  CLICKUP_STORIES_LIST_ID: "901815396340"
  EMAIL_TO_CLICKUP_ID: "work.huutrung@gmail.com:300697285,mazhnguyen@kwayvina.com:300697285,leonkenzo1997@gmail.com:107577458,eric@devcrane.com:55771542"

permissions:
  contents: write

jobs:
  sync-to-clickup:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Get Changed Files and Author
        id: changes
        run: |
          if [ "${{ github.event.inputs.sync_all }}" == "true" ]; then
            echo "Sync all mode - finding all epic and story files"
            EPICS=$(find _bmad-output/planning-artifacts/epics -type f -name "epic.md" 2>/dev/null | tr '\n' ' ')
            STORIES=$(find _bmad-output/planning-artifacts/epics -type f -name "story-*.md" 2>/dev/null | tr '\n' ' ')
            CHANGED="$EPICS $STORIES"
          else
            echo "Git diff mode - finding changed files only"
            CHANGED=$(git diff --name-only HEAD^ HEAD 2>/dev/null | grep -E '_bmad-output/planning-artifacts/epics/.*\.md$' | tr '\n' ' ' || echo "")
          fi
          echo "changed=$CHANGED" >> $GITHUB_OUTPUT
          
          AUTHOR_EMAIL=$(git log -1 --pretty=format:'%ae')
          echo "author=$AUTHOR_EMAIL" >> $GITHUB_OUTPUT
          
          echo "Files to sync: $CHANGED"
          echo "Author: $AUTHOR_EMAIL"

      - name: Sync to ClickUp
        if: steps.changes.outputs.changed != ''
        env:
          CLICKUP_API_KEY: ${{ secrets.CLICKUP_API_KEY }}
          EPICS_LIST: ${{ env.CLICKUP_EPICS_LIST_ID }}
          STORIES_LIST: ${{ env.CLICKUP_STORIES_LIST_ID }}
          EMAIL_MAP: ${{ env.EMAIL_TO_CLICKUP_ID }}
          AUTHOR: ${{ steps.changes.outputs.author }}
        run: |
          echo "Starting sync..."
          
          # Helper functions
          get_user_id() { echo "$EMAIL_MAP" | tr ',' '\n' | grep "^$1:" | cut -d':' -f2 | head -1; }
          
          date_to_ms() {
            if [ -n "$1" ] && [ "$1" != "null" ]; then
              date -d "$1" +%s000 2>/dev/null || echo ""
            fi
          }
          
          hours_to_ms() {
            if [ -z "$1" ] || [ "$1" = "null" ]; then
              return
            fi
            # Convert time formats: 2d → 48h, 1w → 168h
            local val="$1"
            if [[ "$val" =~ ^([0-9]+)d$ ]]; then
              val=$(( ${BASH_REMATCH[1]} * 24 ))  # days to hours
            elif [[ "$val" =~ ^([0-9]+)w$ ]]; then
              val=$(( ${BASH_REMATCH[1]} * 168 ))  # weeks to hours
            elif [[ "$val" =~ ^([0-9]+)h$ ]]; then
              val="${BASH_REMATCH[1]}"  # extract hours
            fi
            # Validate it's a number
            if [[ "$val" =~ ^[0-9]+$ ]]; then
              echo $(( val * 3600000 ))
            fi
          }
          priority_map() {
              case "$1" in critical|urgent) echo 1;; high) echo 2;; normal) echo 3;; low) echo 4;; *) echo "";; esac
            }
          
          # Build epic mapping: epic_id:clickup_id,...
          EPIC_MAP=""
          if ls _bmad-output/planning-artifacts/epics/*/*.md 1>/dev/null 2>&1; then
            for f in _bmad-output/planning-artifacts/epics/*/*.md; do
              FM=$(sed -n '2,/^---$/p' "$f" 2>/dev/null | head -n -1)
              E_ID=$(echo "$FM" | grep "^id:" | sed 's/^id: *//' | sed 's/^"//;s/"$//' | tr -d '\r')
              E_CU=$(echo "$FM" | grep "^clickup_task_id:" | sed 's/^clickup_task_id: *//' | sed 's/^"//;s/"$//;s/^null$//' | tr -d '\r')
              if [ -n "$E_ID" ] && [ -n "$E_CU" ]; then
                EPIC_MAP="${EPIC_MAP}${E_ID}:${E_CU},"
              fi
            done
          fi
          echo "Epic map: $EPIC_MAP"
          
          get_epic_cu() { echo "$EPIC_MAP" | tr ',' '\n' | grep "^$1:" | cut -d':' -f2 | head -1; }
          
          for file in ${{ steps.changes.outputs.changed }}; do
            echo "== Processing: $file =="
            
            FM=$(sed -n '2,/^---$/p' "$file" | head -n -1)
            get_field() { echo "$FM" | grep "^$1:" | sed "s/^$1: *//" | sed 's/^"//;s/"$//;s/^null$//' | tr -d '\r'; }
            
            ID=$(get_field id)
            TITLE=$(get_field title)
            STATUS=$(get_field status)
            CU_ID=$(get_field clickup_task_id)
            EPIC=$(get_field epic_id)
            LINK_TYPE=$(get_field link_type)
            ASSIGNED=$(get_field assigned_to)
            PRIORITY=$(get_field priority)
            START_DATE=$(get_field start_date)
            DUE_DATE=$(get_field due_date)
            TIME_EST=$(get_field time_estimate)
            TAGS_RAW=$(get_field tags)
            
            echo "  $ID: $TITLE | Status=$STATUS | Priority=$PRIORITY | Tags=$TAGS_RAW"
            
            # Build assignees
            ASSIGNEES="[]"
            if [ -n "$ASSIGNED" ]; then
              CLEAN=$(echo "$ASSIGNED" | tr -d '[]"' | tr ',' ' ')
              IDS=""
              for email in $CLEAN; do
                uid=$(get_user_id "$email")
                [ -n "$uid" ] && IDS="${IDS}${uid},"
              done
              if [ -n "$IDS" ]; then
                ASSIGNEES=$(echo "$IDS" | sed 's/,$//' | tr ',' '\n' | jq -R -s -c 'split("\n") | map(select(length > 0) | tonumber)')
              fi
            else
              uid=$(get_user_id "$COMMIT_AUTHOR")
              [ -n "$uid" ] && ASSIGNEES="[$uid]"
            fi
            
            # Type and status mapping - check FILENAME not path
            filename=$(basename "$file")
            if [[ "$filename" == "epic.md" ]]; then
              TYPE="epic"; LIST="$EPICS_LIST"
              case "$STATUS" in 
                to-do) CU_ST="BACKLOG";; 
                in-progress) CU_ST="IN PROGRESS";; 
                done) CU_ST="READY FOR RELEASE";; 
                cancelled) CU_ST="CANCELLED";; 
                *) CU_ST="BACKLOG";; 
              esac
            elif [[ "$filename" == story-*.md ]]; then
              TYPE="story"; LIST="$STORIES_LIST"
              case "$STATUS" in 
                to-do) CU_ST="TO DO";; 
                in-design) CU_ST="IN DESIGN";; 
                in-progress) CU_ST="IN PROGRESS";; 
                ready-for-dev) CU_ST="READY FOR DEV";; 
                in-test) CU_ST="READY FOR TEST";;
                done) CU_ST="READY FOR RELEASE";;
                cancelled) CU_ST="CANCELLED";;
                *) CU_ST="TO DO";; 
              esac
            else
              echo "  Skipping unknown file type: $file"
              continue
            fi
            
            # Description
            DESC=$(awk 'BEGIN{c=0} /^---$/{c++;next} c>=2{print}' "$file" | head -50)
            if [ -n "$EPIC" ]; then
              FULL_DESC=$(printf "**Epic**: %s\n\n---\n\n%s\n\n---\n_Source: %s_" "$EPIC" "$DESC" "$file")
            else
              FULL_DESC=$(printf "%s\n\n---\n_Source: %s_" "$DESC" "$file")
            fi
            
            # Build tags array from frontmatter (use existing tags only, no auto-create)
            TAGS_JSON="[]"
            if [ -n "$TAGS_RAW" ]; then
              CLEAN_TAGS=$(echo "$TAGS_RAW" | tr -d '[]"' | tr ',' '\n' | xargs)
              if [ -n "$CLEAN_TAGS" ]; then
                TAGS_JSON=$(echo "$CLEAN_TAGS" | tr ' ' '\n' | jq -R -s -c 'split("\n") | map(select(length > 0))')
              fi
            fi
            
            # Build payload
            NAME="[$TYPE] $TITLE"
            PAYLOAD=$(jq -n --arg n "$NAME" --arg d "$FULL_DESC" --arg s "$CU_ST" --argjson a "$ASSIGNEES" --argjson t "$TAGS_JSON" \
              '{name:$n, description:$d, status:$s, tags:$t, assignees:$a}')
            
            # Optional fields
            PRI=$(priority_map "$PRIORITY")
            [ -n "$PRI" ] && PAYLOAD=$(echo "$PAYLOAD" | jq --argjson p "$PRI" '. + {priority:$p}')
            
            START_MS=$(date_to_ms "$START_DATE")
            [ -n "$START_MS" ] && PAYLOAD=$(echo "$PAYLOAD" | jq --argjson s "$START_MS" '. + {start_date:$s}')
            
            DUE_MS=$(date_to_ms "$DUE_DATE")
            [ -n "$DUE_MS" ] && PAYLOAD=$(echo "$PAYLOAD" | jq --argjson d "$DUE_MS" '. + {due_date:$d}')
            
            TIME_MS=$(hours_to_ms "$TIME_EST")
            [ -n "$TIME_MS" ] && PAYLOAD=$(echo "$PAYLOAD" | jq --argjson t "$TIME_MS" '. + {time_estimate:$t}')
            
            # Link to epic with relationship type
            if [ "$TYPE" = "story" ] && [ -n "$EPIC" ]; then
              EPIC_CU=$(get_epic_cu "$EPIC")
              if [ -n "$EPIC_CU" ]; then
                RT="${LINK_TYPE:-waiting_on}"  # Default: story waits on epic
                PAYLOAD=$(echo "$PAYLOAD" | jq --arg l "$EPIC_CU" --arg t "$RT" \
                  '. + {links:[{task_id:$l, type:$t}]}')
                echo "  Linking to $EPIC → $EPIC_CU ($RT)"
              fi
            fi
            
            if [ -z "$CU_ID" ]; then
              # Check for existing task by ID in description (sync_all duplicate prevention)
              echo "  Checking for duplicates..."
              EXISTING=$(curl -sf "https://api.clickup.com/api/v2/list/$LIST/task" \
                -H "Authorization: $CLICKUP_API_KEY" | \
                jq -r --arg id "$ID" '.tasks[] | select(.description | contains($id)) | .id' | head -1)
              
              if [ -n "$EXISTING" ]; then
                echo "  Found existing task: $EXISTING (recovering frontmatter)"
                sed -i "s/^clickup_task_id:.*/clickup_task_id: \"$EXISTING\"/" "$file"
                CU_ID="$EXISTING"  # Fall through to update logic
              else
                echo "  Creating..."
                RES=$(curl -s -X POST "https://api.clickup.com/api/v2/list/$LIST/task" \
                  -H "Authorization: $CLICKUP_API_KEY" -H "Content-Type: application/json" \
                  -d "$PAYLOAD" 2>&1) || { echo "  Error: $RES"; continue; }
                
                NEW_ID=$(echo "$RES" | jq -r '.id // empty')
                if [ -n "$NEW_ID" ]; then
                  echo "  Created: $NEW_ID"
                  sed -i "s/^clickup_task_id:.*/clickup_task_id: \"$NEW_ID\"/" "$file"
                else
                  echo "  Failed: $RES"
                fi
              fi
            fi
            
            # Update logic (handles both explicit updates and recovered duplicates)
            if [ -n "$CU_ID" ]; then
              # Verify task exists before updating
              echo "  Verifying task $CU_ID exists..."
              VERIFY=$(curl -sf "https://api.clickup.com/api/v2/task/$CU_ID" \
                -H "Authorization: $CLICKUP_API_KEY" 2>&1)
              
              if [ -z "$VERIFY" ] || echo "$VERIFY" | grep -q "Task not found"; then
                echo "  Task $CU_ID not found (may have been deleted), creating new task..."
                # Reset clickup_task_id and create new
                sed -i "s/^clickup_task_id:.*/clickup_task_id: null/" "$file"
                RES=$(curl -s -X POST "https://api.clickup.com/api/v2/list/$LIST/task" \
                  -H "Authorization: $CLICKUP_API_KEY" -H "Content-Type: application/json" \
                  -d "$PAYLOAD" 2>&1) || { echo "  Error: $RES"; continue; }
                
                NEW_ID=$(echo "$RES" | jq -r '.id // empty')
                if [ -n "$NEW_ID" ]; then
                  echo "  Created: $NEW_ID"
                  sed -i "s/^clickup_task_id:.*/clickup_task_id: \"$NEW_ID\"/" "$file"
                else
                  echo "  Failed: $RES"
                fi
              else
                echo "  Updating $CU_ID..."
                UP=$(echo "$PAYLOAD" | jq 'del(.links_to, .links)')  # Remove link fields from update
                curl -sf -X PUT "https://api.clickup.com/api/v2/task/$CU_ID" \
                  -H "Authorization: $CLICKUP_API_KEY" -H "Content-Type: application/json" \
                  -d "$UP" > /dev/null 2>&1 && echo "  Updated" || echo "  Update failed"
              fi
            fi
          done
          echo "Sync complete"

      - name: Commit ClickUp IDs
        if: steps.changes.outputs.changed != ''
        run: |
          git config user.name "GitHub Action"
          git config user.email "action@github.com"
          git add _bmad-output/
          git diff --staged --quiet || { git commit -m "chore: Update ClickUp IDs [skip ci]" && git push; }

      - name: Sync Comments to ClickUp Activity
        if: steps.changes.outputs.changed != ''
        env:
          CLICKUP_API_KEY: ${{ secrets.CLICKUP_API_KEY }}
        run: |
          echo "Syncing comments to ClickUp Activity..."
          
          for file in ${{ steps.changes.outputs.changed }}; do
            # Get ClickUp task ID
            CU_ID=$(grep "^clickup_task_id:" "$file" | sed 's/^clickup_task_id: *//' | sed 's/^"//;s/"$//' | tr -d '\r')
            [ -z "$CU_ID" ] || [ "$CU_ID" = "null" ] && continue
            
            # Extract new comments from Updates section (lines starting with **)
            UPDATES_SECTION=$(awk '/^## Updates/,/^## |^---$/' "$file" | grep '^\*\*' || echo "")
            [ -z "$UPDATES_SECTION" ] && continue
            
            # Get existing comments to avoid duplicates
            EXISTING=$(curl -sf -H "Authorization: $CLICKUP_API_KEY" \
              "https://api.clickup.com/api/v2/task/$CU_ID/comment" 2>/dev/null | jq -r '.comments[].comment_text' || echo "")
            
            echo "$UPDATES_SECTION" | while read -r line; do
              [ -z "$line" ] && continue
              
              # Check if comment already exists
              COMMENT_TEXT=$(echo "$line" | sed 's/\*\*//g')
              if echo "$EXISTING" | grep -qF "$COMMENT_TEXT"; then
                echo "  Comment already exists, skipping"
                continue
              fi
              
              # Post new comment
              echo "  Adding comment to $CU_ID..."
              curl -sf -X POST "https://api.clickup.com/api/v2/task/$CU_ID/comment" \
                -H "Authorization: $CLICKUP_API_KEY" \
                -H "Content-Type: application/json" \
                -d "{\"comment_text\": \"$COMMENT_TEXT\"}" > /dev/null 2>&1 && \
                echo "  ✓ Comment synced" || echo "  ✗ Failed"
            done
          done
          echo "Comment sync complete"
